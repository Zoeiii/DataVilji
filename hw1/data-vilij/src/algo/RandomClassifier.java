package algo;

import javafx.application.Platform;
import javafx.scene.chart.XYChart;
import ui.AppUI;

import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * @author Ritwik Banerjee
 */
public class RandomClassifier extends Classifier {

    private static final Random RAND = new Random();

    @SuppressWarnings("FieldCanBeLocal")
    // this mock classifier doesn't actually use the data, but a real classifier will
    private DataSet dataset;

    private final int maxIterations;
    private final int updateInterval;
    private AppUI appUI;
    XYChart.Series<Number,Number> series = new XYChart.Series<>();
    private double max, min;

    // currently, this value does not change after instantiation
    private final AtomicBoolean tocontinue;

    @Override
    public int getMaxIterations() {
        return maxIterations;
    }

    @Override
    public int getUpdateInterval() {
        return updateInterval;
    }

    @Override
    public boolean tocontinue() {
        return tocontinue.get();
    }


    public RandomClassifier(DataSet dataset,int[] arug,
                            boolean tocontinue, AppUI appUI) {
        this.dataset = dataset;
        this.maxIterations = arug[0];
        this.updateInterval = arug[1];
        this.tocontinue = new AtomicBoolean(tocontinue);
        this.appUI = appUI;
        this.max = appUI.getXMax();
        this.min = appUI.getXMin();
    }

    @Override
    public void run() {
        appUI.getStartOverButton().setVisible(false);
        Platform.runLater(() -> {
            appUI.getChart().getData().clear();
            appUI.getChart().getData().add(series);
            appUI.displayClassData();
        });
        for (int i = 1; i <= maxIterations; i++) {
            int xCoefficient = new Double(RAND.nextDouble() * 100).intValue();
            int yCoefficient= new Double(RAND.nextDouble() * 100).intValue();
            while(yCoefficient==0)
                yCoefficient = new Double(RAND.nextDouble() * 100).intValue();
            int constant = new Double(RAND.nextDouble() * 100).intValue();

            // this is the real output of the classifier
            output = Arrays.asList(xCoefficient, yCoefficient, constant);
            appUI.getRunButton().setDisable(true);
            appUI.getScrnshotButton().setDisable(true);
            appUI.getConfu().setDisable(true);
            // everything below is just for internal viewing of how the output is changing
            // in the final project, such changes will be dynamically visible in the UI
            if (i % updateInterval == 0) {
                System.out.printf("Iteration number %d: ", i);
                flush();
                try {
                    updateChart(i);
                } catch (InterruptedException e) {
                    //main thread will send a interrupt to notify that thread can continue to update
                    synchronized (this){this.notify();}
                }
            }
/*            if (i > maxIterations * .6 && RAND.nextDouble() < 0.05) {
                System.out.printf("Iteration number %d: ", i);
                flush();
                break;
            }
            */
        }
        appUI.getScrnshotButton().setDisable(false);
        appUI.getRunButton().setDisable(true);
        appUI.getConfu().setDisable(false);
        appUI.getStartOverButton().setVisible(true);

    }

    /**
     * Update the chart according to the value generated by algo: Ax+By+C, value A,B,and C
     *      thread sleep after line generated, and wait if user choose to not auto update the chart
     *      enable the screen shot button when thread waits
     *
     * @param current: the current iteration, helped to determine the process. Ex: 90% finished
     * @throws InterruptedException: throw exception when thread are interrupted by another thread.
     */
    public void updateChart(int current) throws InterruptedException {
        int a =getOutput().get(0), b=getOutput().get(1), c = getOutput().get(2);
        double y = ((-c)-(a * min)) / b, y2 = ((-c)-(a * max)) / b;
        //    double y = (a * min+c) / b, y2 = (a * max+c) / b;

        Platform.runLater(() -> {
            if(series.getData().size()>0)   series.getData().clear();
            series.getData().add(new XYChart.Data<>(max, y2));
            series.getData().add(new XYChart.Data<>(min, y));
        });
        //let the thread sleep for half second after each iteration
        Thread.sleep(500);

        //finishes last update without wait. Then end the thread
        if(!tocontinue() && (maxIterations-current >= updateInterval)) {
            appUI.getScrnshotButton().setDisable(false);
            appUI.getRunButton().setDisable(false);
            //if user choose not auto-display, wait until user display next iter
            synchronized (this){this.wait();}
        }
    }

    // for internal viewing only
    protected void flush() {
        System.out.printf("%d\t%d\t%d%n", output.get(0), output.get(1), output.get(2));
    }
}
